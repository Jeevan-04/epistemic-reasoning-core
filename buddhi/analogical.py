"""
ANALOGICAL HYPOTHESIS GENERATOR

Constraint-based analogy for hypothesis generation ONLY.
Never directly creates beliefs.

Philosophy:
- Analogy proposes, epistemics disposes
- Analogy creates conjectures with low confidence
- All analogical hypotheses require confirmation
- Negative analogy blocks inference (shared structure but different properties)

Mechanism:
- Extract relational patterns from belief chains
- Find structural overlaps between entity pairs
- Generate hypotheses based on shared explanatory chains
- Tag all outputs as "analogical_hypothesis" (requires validation)

Example:
    Known:
        Birds fly
        Fish swim
        Birds breathe air
    
    Query: Do fish breathe air?
    
    Analogy:
        Bird:flight :: Fish:swimming
        Shared: vertebrate, locomotion
        Differs: respiratory_medium
    
    Output: HYPOTHESIS (low confidence, requires confirmation)
            "Fish may breathe water (analogical hypothesis)"
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any
from collections import defaultdict


@dataclass
class AnalogicalMapping:
    """
    Structural mapping between two entity pairs.
    
    Example:
        source: (bird, flight)
        target: (fish, swimming)
        shared_structure: [vertebrate, locomotion]
        differing_properties: [respiratory_medium]
    """
    source_entities: tuple[str, ...]
    target_entities: tuple[str, ...]
    shared_predicates: list[str]
    differing_predicates: list[str]
    confidence: float = 0.3  # Analogies start with low confidence
    
    def to_dict(self) -> dict:
        return {
            "source": self.source_entities,
            "target": self.target_entities,
            "shared": self.shared_predicates,
            "differs": self.differing_predicates,
            "confidence": self.confidence,
        }


@dataclass
class AnalogicalHypothesis:
    """
    Hypothesis generated by analogical reasoning.
    
    CRITICAL: This is NOT a belief. It's a conjecture that requires validation.
    """
    hypothesis_id: str
    statement: str  # Proposed statement
    canonical: dict  # Canonical form of hypothesis
    confidence: float  # Low confidence (requires confirmation)
    source_mapping: AnalogicalMapping  # Which analogy generated this
    supporting_beliefs: list[str]  # Beliefs used in analogy
    requires_validation: bool = True  # Always true for analogical hypotheses
    metadata: dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> dict:
        return {
            "id": self.hypothesis_id,
            "type": "analogical_hypothesis",
            "statement": self.statement,
            "canonical": self.canonical,
            "confidence": self.confidence,
            "mapping": self.source_mapping.to_dict(),
            "supporting_beliefs": self.supporting_beliefs,
            "requires_validation": self.requires_validation,
            "metadata": self.metadata,
        }


class AnalogicalReasoner:
    """
    Generate hypotheses via constraint-based analogy.
    
    NEVER creates beliefs directly.
    Only proposes hypotheses with low confidence.
    """
    
    def __init__(self, min_shared_predicates: int = 2):
        """
        Args:
            min_shared_predicates: Minimum shared structure for valid analogy
        """
        self.min_shared_predicates = min_shared_predicates
        self.generated_hypotheses: list[AnalogicalHypothesis] = []
    
    def find_analogies(self, entity: str, graph: Any) -> list[AnalogicalMapping]:
        """
        Find analogous entities with shared relational structure.
        
        Args:
            entity: Entity to find analogies for
            graph: ChittaGraph with beliefs
        
        Returns:
            List of analogical mappings
        """
        mappings = []
        
        # Get all beliefs about this entity
        entity_beliefs = [b for b in graph.beliefs.values()
                         if entity in b.entities and b.active]
        
        # Extract predicates for this entity
        entity_predicates = set()
        for belief in entity_beliefs:
            entity_predicates.update(belief.predicates)
        
        # Find other entities with overlapping predicates
        predicate_to_entities = defaultdict(set)
        for belief in graph.beliefs.values():
            if belief.active:
                for pred in belief.predicates:
                    for ent in belief.entities:
                        if ent != entity:
                            predicate_to_entities[pred].add(ent)
        
        # Calculate overlap for each candidate
        candidates = {}
        for pred in entity_predicates:
            for other_entity in predicate_to_entities[pred]:
                if other_entity not in candidates:
                    candidates[other_entity] = {'shared': set(), 'differs': set()}
                candidates[other_entity]['shared'].add(pred)
        
        # Find differing predicates
        for other_entity, data in candidates.items():
            other_beliefs = [b for b in graph.beliefs.values()
                           if other_entity in b.entities and b.active]
            other_predicates = set()
            for belief in other_beliefs:
                other_predicates.update(belief.predicates)
            
            # Predicates in other but not in entity
            data['differs'] = other_predicates - entity_predicates
        
        # Create mappings for entities with sufficient shared structure
        for other_entity, data in candidates.items():
            if len(data['shared']) >= self.min_shared_predicates:
                mapping = AnalogicalMapping(
                    source_entities=(entity,),
                    target_entities=(other_entity,),
                    shared_predicates=list(data['shared']),
                    differing_predicates=list(data['differs']),
                    confidence=len(data['shared']) / (len(data['shared']) + len(data['differs']) + 1),
                )
                mappings.append(mapping)
        
        return mappings
    
    def generate_hypothesis(
        self,
        query_entities: set[str],
        query_predicate: str,
        graph: Any
    ) -> AnalogicalHypothesis | None:
        """
        Generate hypothesis for unknown query via analogy.
        
        Args:
            query_entities: Entities in question
            query_predicate: Predicate being asked about
            graph: ChittaGraph with beliefs
        
        Returns:
            Analogical hypothesis or None if no valid analogy found
        """
        if len(query_entities) != 1:
            return None  # Only handle single-entity queries for now
        
        entity = list(query_entities)[0]
        
        # Find analogous entities
        mappings = self.find_analogies(entity, graph)
        
        if not mappings:
            return None
        
        # Check if any analogous entity has the query predicate
        for mapping in mappings:
            other_entity = mapping.target_entities[0]
            
            # Does other entity have this predicate?
            other_beliefs = [b for b in graph.beliefs.values()
                           if other_entity in b.entities 
                           and query_predicate in b.predicates
                           and b.active]
            
            if other_beliefs:
                # Generate hypothesis via analogy
                source_belief = other_beliefs[0]
                
                # Create analogical hypothesis
                hypothesis_statement = source_belief.statement_text.replace(
                    other_entity, entity
                )
                
                hypothesis = AnalogicalHypothesis(
                    hypothesis_id=f"hyp_analog_{entity}_{query_predicate}",
                    statement=hypothesis_statement,
                    canonical={
                        "entity": entity,
                        "predicate": query_predicate,
                        "type": "analogical_hypothesis"
                    },
                    confidence=mapping.confidence * 0.5,  # Low confidence
                    source_mapping=mapping,
                    supporting_beliefs=[source_belief.id],
                    metadata={
                        "source_entity": other_entity,
                        "shared_structure": mapping.shared_predicates,
                        "differs": mapping.differing_predicates,
                    }
                )
                
                self.generated_hypotheses.append(hypothesis)
                return hypothesis
        
        return None
    
    def check_negative_analogy(
        self,
        entity1: str,
        entity2: str,
        graph: Any
    ) -> dict[str, list[str]]:
        """
        Check for negative analogy: shared structure but differing properties.
        
        Negative analogy BLOCKS inference.
        
        Example:
            Bird and Fish both vertebrates (shared)
            But bird breathes air, fish breathes water (differs)
            â‡’ Cannot infer fish respiratory properties from birds
        
        Returns:
            Dict with 'shared' and 'differs' keys
        """
        beliefs1 = [b for b in graph.beliefs.values()
                   if entity1 in b.entities and b.active]
        beliefs2 = [b for b in graph.beliefs.values()
                   if entity2 in b.entities and b.active]
        
        preds1 = set()
        preds2 = set()
        for b in beliefs1:
            preds1.update(b.predicates)
        for b in beliefs2:
            preds2.update(b.predicates)
        
        return {
            "shared": list(preds1 & preds2),
            "differs": list((preds1 - preds2) | (preds2 - preds1)),
        }
